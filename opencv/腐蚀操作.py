"""
结构元素A(背景色黑色)，感兴趣区域B(感兴趣区域白色)
使用结构元素，在感兴趣的区域做平移，
如果平移后，B包含A, 则保留A中心点与B区域重合的位置
如果不包含则，腐蚀掉A中心点与B区域重合的位置，就是把白色变黑色

创建结构元素
    cv2.getStructuringElement(shape, ksize)
        shape: 结构元素形状
        MORPH_RECT = 0 矩形
腐蚀动画效果可预览 -- 动态网格腐蚀系统.html (这是腐蚀一次的效果)
一次就是一轮
"""
import cv2
import numpy as np

# 绘制背景色
bg = np.zeros((10, 10), 'u1')
# 绘制感兴趣区域
lick = bg[3:7, 3:7] = 255
"""
[[  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0 255 255 255 255   0   0   0]
 [  0   0   0 255 255 255 255   0   0   0]
 [  0   0   0 255 255 255 255   0   0   0]
 [  0   0   0 255 255 255 255   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]]
"""
print(bg)

# 创建结构元素
# 结构元素，一般是奇数，便于人为确定中心点位置

kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3,3))
"""
[[1 1 1]
 [1 1 1]
 [1 1 1]]
"""
print(kernel)

# 腐蚀
# iterations 腐蚀次数
erode_img = cv2.erode(bg, kernel, iterations=1)
"""
其原理就是，结构元素在整个背景中做平移操作，如果结构元素平移至与感兴趣区域有重叠时，
但是结构元素并未完全包含在感兴趣区域时，结构元素中心点位置，与感兴趣区域重叠的部分像素被改标记为0也就是腐蚀
如果结构元素完全包含在感兴趣区域时，即便结构元素中心点与感兴趣区域重叠也不做标记
等到，一轮标记完成时，标记为0的区域，像素被改为0

腐蚀只针对白色区域，也就是感兴趣区域做的是缩小白色区域范围的操作，所以腐蚀必然会影响，不需要被腐蚀的部分，这个时候就需要做膨胀操作

腐蚀的作用是，用来处理图像中不需要的部分，如噪点等。
"""

"""
[[  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0 255 255   0   0   0   0]
 [  0   0   0   0 255 255   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0   0]]
"""
print(erode_img)
